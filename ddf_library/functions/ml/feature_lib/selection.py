#!/usr/bin/env python3
# -*- coding: utf-8 -*-

__author__ = "Lucas Miguel S Ponce"
__email__ = "lucasmsp@gmail.com"

from pycompss.api.task import task
from pycompss.functions.reduce import merge_reduce
from pycompss.api.api import compss_wait_on

from ddf_library.ddf import DDF
from ddf_library.utils import generate_info

import numpy as np


class VectorAssembler(object):

    """
    Vector Assembler is a transformer that combines a given list of columns
    into a single vector column. It is useful for combining raw features and
    features generated by different feature transformers into a single feature
    vector, in order to train ML models.

    Vector Assembler accepts the following input column types: all numeric
    types, boolean type, and vector type. In each row, the values of the
    input columns will be concatenated into a vector in the specified order.

    :Example:

    >>> assembler = VectorAssembler(input_col=["x", "y"], output_col="features")
    >>> ddf2 = assembler.transform(ddf1)
    """

    def __init__(self, input_col, output_col=None, remove=False):
        """
        :param input_col: List of columns;
        :param output_col: Output column name.
        """

        if not output_col:
            output_col = 'features'

        self.settings = dict()
        self.settings['input_col'] = input_col
        self.settings['output_col'] = output_col
        self.settings['remove'] = remove

    def transform(self, data):
        """
        :param data: DDF
        :return: DDF
        """

        def task_vector_assembler(df, params):
            return _feature_assemble_(df, params)

        uuid_key = data._ddf_add_task(task_name='vector_assembler',
                                      status='WAIT', lazy=self.OPT_SERIAL,
                                      function=[task_vector_assembler,
                                                self.settings],
                                      parent=[data.last_uuid],
                                      n_output=1, n_input=1)

        data._set_n_input(uuid_key, data.settings['input'])
        return DDF(task_list=data.task_list, last_uuid=uuid_key)


def _feature_assemble_(df, settings):
    """Perform a partial feature assembler."""
    cols = settings['input_col']
    name = settings['output_col']
    frag = settings['id_frag']
    remove = settings['remove']

    cols = [col for col in cols if col in df.columns]
    if len(cols) == 0:
        raise Exception("These columns don't belong to this data set.")

    if len(df) == 0:
        new_column = np.nan
    else:

        # get the first row to see the type format of each column
        rows = df[cols].iloc[0].values.tolist()
        is_list, not_list = check_fields(rows, cols)

        if len(is_list) == 0:
            new_column = df[cols].values.tolist()
        else:
            tmp1 = df[not_list].values
            tmp2 = np.array(df[is_list].sum(axis=1).values.tolist())

            new_column = np.concatenate((tmp1, tmp2), axis=1).tolist()

    if remove:
        df.drop(cols, axis=1, inplace=True)

    df[name] = new_column

    info = generate_info(df, frag)
    return df, info


def check_fields(rows, cols):
    """Check which fields are a list or a primitive type."""
    is_list = []
    not_list = []
    if len(rows) > 0:
        for item, col_name in zip(rows, cols):
            if isinstance(item, list):
                is_list.append(col_name)
            else:
                not_list.append(col_name)
    return is_list, not_list


class VectorSlicer(object):
    """
    Vector Slicer class takes a feature vector and outputs a new feature
    vector with a sub-array of the original features.

    The output vector will order features with the selected indices first
    (in the order given), followed by the selected names (in the order given).

    :Example:

    >>> ddf = VectorSlicer(input_col='features', indices=[0, 5]).transform(ddf)
    """

    def __init__(self, input_col, output_col=None, indices=None):
        """
        :param input_col: Feature vector field.
        :param output_col: New feature vector field (overwrite by default)
        :param indices: indices list
        """
        if not output_col:
            output_col = input_col

        self.settings = dict()
        self.settings['input_col'] = input_col
        self.settings['output_col'] = output_col

        if indices is None:
            raise Exception('At least one feature must be selected.')

        self.settings['indices'] = indices

    def transform(self, data):
        """
        :param data: DDF
        :return: DDF
        """

        def task_vector_slicer(df, params):
            return _vector_slicer(df, params)

        uuid_key = data._ddf_add_task(task_name='vector_slicer',
                                      status='WAIT', lazy=self.OPT_SERIAL,
                                      function=[task_vector_slicer,
                                                self.settings],
                                      parent=[data.last_uuid],
                                      n_output=1, n_input=1)

        data._set_n_input(uuid_key, data.settings['input'])
        return DDF(task_list=data.task_list, last_uuid=uuid_key)


def _vector_slicer(df, settings):

    output_col = settings['output_col']
    frag = settings['id_frag']

    if len(df) == 0:
        df[output_col] = np.nan

    else:

        input_col = settings['input_col']
        idx = settings['indices']

        values = np.array(df[input_col].tolist())[:, idx]
        df[output_col] = values.tolist()

    info = generate_info(df, frag)
    return df, info
